//! Schema validation tests
//!
//! These tests ensure that JSON schemas generated by schemars correctly
//! reflect serde rename attributes. Without proper schemars configuration,
//! #[serde(rename = "entityName")] would generate schema with "entity_name"
//! causing MCP clients to send wrong field names.

use schemars::JsonSchema;
use serde_json::Value;

use memory_mcp_rs::graph::{Entity, Relation, ObservationInput, ObservationDeletion};

/// Get schema as JSON Value for inspection
fn get_schema<T: JsonSchema>() -> Value {
    let schema = schemars::schema_for!(T);
    serde_json::to_value(schema).expect("Failed to serialize schema")
}

/// Check if schema properties contain expected field name
fn schema_has_property(schema: &Value, field_name: &str) -> bool {
    schema["properties"].get(field_name).is_some()
}

/// Check schema does NOT contain a field (for checking snake_case doesn't leak)
fn schema_missing_property(schema: &Value, field_name: &str) -> bool {
    schema["properties"].get(field_name).is_none()
}

// ============================================================================
// ENTITY SCHEMA TESTS
// ============================================================================

#[test]
fn test_entity_schema_has_entity_type_camel_case() {
    let schema = get_schema::<Entity>();

    // Must have camelCase "entityType"
    assert!(
        schema_has_property(&schema, "entityType"),
        "Entity schema missing 'entityType' field. Schema: {:#}",
        schema["properties"]
    );

    // Must NOT have snake_case "entity_type"
    assert!(
        schema_missing_property(&schema, "entity_type"),
        "Entity schema incorrectly contains 'entity_type' instead of 'entityType'"
    );
}

#[test]
fn test_entity_schema_has_all_required_fields() {
    let schema = get_schema::<Entity>();

    assert!(schema_has_property(&schema, "name"), "Missing 'name'");
    assert!(schema_has_property(&schema, "entityType"), "Missing 'entityType'");
    assert!(schema_has_property(&schema, "observations"), "Missing 'observations'");
}

// ============================================================================
// RELATION SCHEMA TESTS
// ============================================================================

#[test]
fn test_relation_schema_has_relation_type_camel_case() {
    let schema = get_schema::<Relation>();

    // Must have camelCase "relationType"
    assert!(
        schema_has_property(&schema, "relationType"),
        "Relation schema missing 'relationType' field. Schema: {:#}",
        schema["properties"]
    );

    // Must NOT have snake_case "relation_type"
    assert!(
        schema_missing_property(&schema, "relation_type"),
        "Relation schema incorrectly contains 'relation_type' instead of 'relationType'"
    );
}

#[test]
fn test_relation_schema_has_all_required_fields() {
    let schema = get_schema::<Relation>();

    assert!(schema_has_property(&schema, "from"), "Missing 'from'");
    assert!(schema_has_property(&schema, "to"), "Missing 'to'");
    assert!(schema_has_property(&schema, "relationType"), "Missing 'relationType'");
}

// ============================================================================
// OBSERVATION INPUT SCHEMA TESTS (this was the bug!)
// ============================================================================

#[test]
fn test_observation_input_schema_has_entity_name_camel_case() {
    let schema = get_schema::<ObservationInput>();

    // Must have camelCase "entityName" - THIS WAS THE BUG!
    assert!(
        schema_has_property(&schema, "entityName"),
        "ObservationInput schema missing 'entityName' field. Schema: {:#}",
        schema["properties"]
    );

    // Must NOT have snake_case "entity_name"
    assert!(
        schema_missing_property(&schema, "entity_name"),
        "ObservationInput schema incorrectly contains 'entity_name' instead of 'entityName'. \
         This causes MCP clients to send wrong field names!"
    );
}

#[test]
fn test_observation_input_schema_has_contents_array() {
    let schema = get_schema::<ObservationInput>();

    // Must have "contents" field
    assert!(
        schema_has_property(&schema, "contents"),
        "ObservationInput schema missing 'contents' field"
    );

    // Must NOT have "observation" (singular) - common mistake
    assert!(
        schema_missing_property(&schema, "observation"),
        "ObservationInput schema incorrectly contains 'observation' instead of 'contents'"
    );
}

#[test]
fn test_observation_input_schema_all_fields() {
    let schema = get_schema::<ObservationInput>();

    assert!(schema_has_property(&schema, "entityName"), "Missing 'entityName'");
    assert!(schema_has_property(&schema, "contents"), "Missing 'contents'");

    // Verify contents is array type
    let contents_type = &schema["properties"]["contents"]["type"];
    assert_eq!(
        contents_type, "array",
        "contents should be array type, got: {}",
        contents_type
    );
}

// ============================================================================
// OBSERVATION DELETION SCHEMA TESTS
// ============================================================================

#[test]
fn test_observation_deletion_schema_has_entity_name_camel_case() {
    let schema = get_schema::<ObservationDeletion>();

    assert!(
        schema_has_property(&schema, "entityName"),
        "ObservationDeletion schema missing 'entityName' field"
    );

    assert!(
        schema_missing_property(&schema, "entity_name"),
        "ObservationDeletion schema incorrectly contains 'entity_name'"
    );
}

#[test]
fn test_observation_deletion_schema_all_fields() {
    let schema = get_schema::<ObservationDeletion>();

    assert!(schema_has_property(&schema, "entityName"), "Missing 'entityName'");
    assert!(schema_has_property(&schema, "observations"), "Missing 'observations'");
}

// ============================================================================
// COMPREHENSIVE SERDE RENAME SYNC TEST
// ============================================================================

/// This test ensures ALL serde renames are reflected in schemas.
/// If this test fails, add "serde" feature to schemars in Cargo.toml!
#[test]
fn test_all_serde_renames_reflected_in_schema() {
    let failures: Vec<String> = vec![
        // Entity
        check_rename::<Entity>("entityType", "entity_type"),
        // Relation
        check_rename::<Relation>("relationType", "relation_type"),
        // ObservationInput
        check_rename::<ObservationInput>("entityName", "entity_name"),
        // ObservationDeletion
        check_rename::<ObservationDeletion>("entityName", "entity_name"),
    ]
    .into_iter()
    .flatten()
    .collect();

    if !failures.is_empty() {
        panic!(
            "Schema/serde rename mismatch detected!\n\
             This usually means schemars is missing the 'serde' feature.\n\
             Fix: schemars = {{ version = \"...\", features = [\"derive\", \"serde\"] }}\n\n\
             Failures:\n{}",
            failures.join("\n")
        );
    }
}

fn check_rename<T: JsonSchema>(expected: &str, snake_case: &str) -> Option<String> {
    let schema = get_schema::<T>();
    let type_name = std::any::type_name::<T>();

    if schema_missing_property(&schema, expected) {
        return Some(format!(
            "  - {} missing '{}' (probably showing '{}' instead)",
            type_name, expected, snake_case
        ));
    }
    if schema_has_property(&schema, snake_case) {
        return Some(format!(
            "  - {} has snake_case '{}' instead of '{}'",
            type_name, snake_case, expected
        ));
    }
    None
}

// ============================================================================
// SCHEMA REQUIRED FIELDS TEST
// ============================================================================

#[test]
fn test_observation_input_required_fields() {
    let schema = get_schema::<ObservationInput>();

    // Check required array exists and contains our fields
    let required = schema["required"].as_array();
    assert!(required.is_some(), "Schema should have required fields");

    let required: Vec<&str> = required
        .unwrap()
        .iter()
        .filter_map(|v| v.as_str())
        .collect();

    assert!(
        required.contains(&"entityName"),
        "entityName should be required, got: {:?}",
        required
    );
    assert!(
        required.contains(&"contents"),
        "contents should be required, got: {:?}",
        required
    );
}

// ============================================================================
// TOOL ARGS SCHEMA TESTS (what MCP clients actually receive)
// ============================================================================

/// Test the actual schema that MCP clients receive for add_observations
/// This is the wrapper struct used in main.rs
#[derive(serde::Deserialize, JsonSchema)]
struct AddObservationsArgs {
    observations: Vec<ObservationInput>,
}

#[test]
fn test_add_observations_args_schema() {
    let schema = get_schema::<AddObservationsArgs>();

    // Check observations field exists
    assert!(
        schema_has_property(&schema, "observations"),
        "AddObservationsArgs missing 'observations' field"
    );

    // Get the nested schema for ObservationInput items
    // In JSON Schema, array items are defined in "items" or "$defs"
    let schema_str = serde_json::to_string_pretty(&schema).unwrap();

    // Must contain entityName (camelCase)
    assert!(
        schema_str.contains("entityName"),
        "Schema must contain 'entityName', got:\n{}",
        schema_str
    );

    // Must contain contents
    assert!(
        schema_str.contains("contents"),
        "Schema must contain 'contents', got:\n{}",
        schema_str
    );

    // Must NOT contain snake_case entity_name
    assert!(
        !schema_str.contains("entity_name"),
        "Schema incorrectly contains 'entity_name' (snake_case). \
         MCP clients will send wrong field names!\n{}",
        schema_str
    );

    // Must NOT contain singular "observation" (wrong field name)
    // Only check in properties context, not in descriptions
    let props_section = &schema["properties"];
    let props_str = serde_json::to_string(props_section).unwrap();
    assert!(
        !props_str.contains(r#""observation""#),
        "Schema properties incorrectly contain 'observation' instead of 'contents'"
    );
}

/// Print full schema for debugging (run with --nocapture to see)
#[test]
fn test_print_observation_input_schema() {
    let schema = get_schema::<ObservationInput>();
    let pretty = serde_json::to_string_pretty(&schema).unwrap();
    println!("ObservationInput schema:\n{}", pretty);

    // This test always passes - it's for debugging
    assert!(true);
}
